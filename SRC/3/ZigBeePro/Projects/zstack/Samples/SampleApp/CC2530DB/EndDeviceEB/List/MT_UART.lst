###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         28/Sep/2018  17:56:17 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Components\mt\MT_ #
#                          UART.c                                             #
#    Command line       =  -f E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530 #
#                          DB\f8wEndev.cfg (-DCPU32MHZ -DROOT=__near_func     #
#                          -DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6         #
#                          -DMAC_CFG_RX_MAX=3) -f E:\BYSJ\bysj2018\SRC\3\ZigB #
#                          eePro\Projects\zstack\Samples\SampleApp\CC2530DB\. #
#                          .\..\..\Tools\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO  #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1234                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 E:\BYSJ\bysj2018\SRC\3\ZigB #
#                          eePro\Components\mt\MT_UART.c -D NWK_AUTO_POLL -D  #
#                          ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC  #
#                          -D LCD_SUPPORTED=DEBUG -lC                         #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\EndDeviceEB\List\ -lA    #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\EndDeviceEB\List\        #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\EndDeviceEB\Obj\ -e      #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\ -I                   #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\Source\ -I            #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\ZMain\TI2530DB\ #
#                           -I E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\hal\include\ -I E:\BYSJ\bysj2018\SRC\3\ZigBe #
#                          ePro\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\Components\hal\target\CC2530EB\ -I    #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\mac\include\ -I E:\BYSJ\bysj2018\SRC\3\ZigBeePro #
#                          \Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\mac\high_level\ -I             #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\mac\low_level\srf04\ -I                          #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\mac\low_level\srf04\single_chip\ -I              #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\mt\ -I E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          Components\osal\include\ -I                        #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\services\saddr\ -I E:\BYSJ\bysj2018\SRC\3\ZigBee #
#                          Pro\Projects\zstack\Samples\SampleApp\CC2530DB\..\ #
#                          ..\..\..\..\Components\services\sdata\ -I          #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\stack\af\ -I E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\stack\nwk\ -I                     #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\stack\sapi\ -I E:\BYSJ\bysj2018\SRC\3\ZigBeePro\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\stack\sec\ -I                   #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\stack\sys\ -I E:\BYSJ\bysj2018\SRC\3\ZigBeePro\P #
#                          rojects\zstack\Samples\SampleApp\CC2530DB\..\..\.. #
#                          \..\..\Components\stack\zdo\ -I                    #
#                          E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\zmac\ -I E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projec #
#                          ts\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\. #
#                          .\Components\zmac\f8w\ -Ohz --require_prototypes   #
#    List file          =  E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\EndDeviceEB\List\MT_UART #
#                          .lst                                               #
#    Object file        =  E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\EndDeviceEB\Obj\MT_UART. #
#                          r51                                                #
#                                                                             #
#                                                                             #
###############################################################################

E:\BYSJ\bysj2018\SRC\3\ZigBeePro\Components\mt\MT_UART.c
      1          /***************************************************************************************************
      2            Filename:       MT_UART.c
      3            Revised:        $Date: 2009-03-12 16:25:22 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19404 $
      5          
      6            Description:  This module handles anything dealing with the serial port.
      7          
      8            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.anlde.com.
     37          
     38          ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "hal_uart.h"
     46          #include "MT.h"
     47          #include "MT_UART.h"
     48          #include "OSAL_Memory.h"
     49          
     50          
     51          /***************************************************************************************************
     52           * MACROS
     53           ***************************************************************************************************/
     54          
     55          /***************************************************************************************************
     56           * CONSTANTS
     57           ***************************************************************************************************/
     58          /* State values for ZTool protocal */
     59          #define SOP_STATE      0x00
     60          #define CMD_STATE1     0x01
     61          #define CMD_STATE2     0x02
     62          #define LEN_STATE      0x03
     63          #define DATA_STATE     0x04
     64          #define FCS_STATE      0x05
     65          
     66          /***************************************************************************************************
     67           *                                         GLOBAL VARIABLES
     68           ***************************************************************************************************/
     69          /* Used to indentify the application ID for osal task */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     70          byte App_TaskID;
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     71          
     72          /* ZTool protocal parameters */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          uint8 state = 0;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     74          uint8  CMD_Token[2];
   \                     CMD_Token:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     75          uint8  LEN_Token;
   \                     LEN_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     76          uint8  FSC_Token;
   \                     FSC_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     77          mtOSALSerialData_t  *pMsg;
   \                     pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     78          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     79          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     80          uint8 UART1_RX_STA = 0;
   \                     UART1_RX_STA:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     81          uint8 Uart1RxLen;
   \                     Uart1RxLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     82          uint8 UART1_RX_BUF[127];
   \                     UART1_RX_BUF:
   \   000000                DS 127
   \   00007F                REQUIRE __INIT_XDATA_Z
     83          
     84          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     85          uint16  MT_UartMaxZAppBufLen;
     86          bool    MT_UartZAppRxStatus;
     87          #endif
     88          
     89          
     90          /***************************************************************************************************
     91           *                                          LOCAL FUNCTIONS
     92           ***************************************************************************************************/
     93          
     94          /***************************************************************************************************
     95           * @fn      MT_UartInit
     96           *
     97           * @brief   Initialize MT with UART support
     98           *
     99           * @param   None
    100           *
    101           * @return  None
    102          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    103          void MT_UartInit ()
   \                     MT_UartInit:
    104          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 29
   \   000004   74E3         MOV     A,#-0x1d
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    105            halUARTCfg_t uartConfig;
    106          
    107            /* Initialize APP ID */
    108            App_TaskID = 0;
   \   000009   90....       MOV     DPTR,#App_TaskID
   \   00000C   E4           CLR     A
   \   00000D   F0           MOVX    @DPTR,A
    109          
    110            /* UART Configuration */
    111            uartConfig.configured           = TRUE;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   04           INC     A
   \   000015   F0           MOVX    @DPTR,A
    112            uartConfig.baudRate             = MT_UART_DEFAULT_BAUDRATE;
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   7404         MOV     A,#0x4
   \   00001B   F0           MOVX    @DPTR,A
    113            //uartConfig.flowControl          = MT_UART_DEFAULT_OVERFLOW;
    114            uartConfig.flowControl          = FALSE;
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
    115            uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
   \   000023   7403         MOV     A,#0x3
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   7440         MOV     A,#0x40
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E4           CLR     A
   \   00002D   F0           MOVX    @DPTR,A
    116            uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
   \   00002E   740A         MOV     A,#0xa
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   7480         MOV     A,#-0x80
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   E4           CLR     A
   \   000038   F0           MOVX    @DPTR,A
    117            uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
   \   000039   7412         MOV     A,#0x12
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   7480         MOV     A,#-0x80
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   E4           CLR     A
   \   000043   F0           MOVX    @DPTR,A
    118            uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
   \   000044   7405         MOV     A,#0x5
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   7406         MOV     A,#0x6
   \   00004B   F0           MOVX    @DPTR,A
    119            uartConfig.intEnable            = TRUE;
   \   00004C   7416         MOV     A,#0x16
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   7401         MOV     A,#0x1
   \   000053   F0           MOVX    @DPTR,A
    120          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    121            uartConfig.callBackFunc         = MT_UartProcessZToolData; //串口接受回调函数
   \   000054   741B         MOV     A,#0x1b
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   74..         MOV     A,#??MT_UartProcessZToolData?relay & 0xff
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   74..         MOV     A,#(??MT_UartProcessZToolData?relay >> 8) & 0xff
   \   00005F   F0           MOVX    @DPTR,A
    122          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    123            uartConfig.callBackFunc         = MT_UartProcessZAppData;
    124          #else
    125            uartConfig.callBackFunc         = NULL;
    126          #endif
    127          
    128            /* Start UART */
    129          #if defined (MT_UART_DEFAULT_PORT)
    130            HalUARTOpen (MT_UART_DEFAULT_PORT, &uartConfig);
   \   000060                ; Setup parameters for call to function HalUARTOpen
   \   000060   85..82       MOV     DPL,?XSP + 0
   \   000063   85..83       MOV     DPH,?XSP + 1
   \   000066   AA82         MOV     R2,DPL
   \   000068   AB83         MOV     R3,DPH
   \   00006A   7900         MOV     R1,#0x0
   \   00006C   12....       LCALL   ??HalUARTOpen?relay
    131          #ifdef COOR_DEVICE_UART1 //配置串口1
    132            HalUARTOpen (1, &uartConfig);
    133          #endif
    134          #else
    135            /* Silence IAR compiler warning */
    136            (void)uartConfig;
    137          #endif
    138          
    139            /* Initialize for ZApp */
    140          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    141            /* Default max bytes that ZAPP can take */
    142            MT_UartMaxZAppBufLen  = 1;
    143            MT_UartZAppRxStatus   = MT_UART_ZAPP_RX_READY;
    144          #endif
    145          
    146          }
   \   00006F   741D         MOV     A,#0x1d
   \   000071   12....       LCALL   ?DEALLOC_XSTACK8
   \   000074                REQUIRE ?Subroutine0
   \   000074                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    147          
    148          /***************************************************************************************************
    149           * @fn      MT_SerialRegisterTaskID
    150           *
    151           * @brief   This function registers the taskID of the application so it knows
    152           *          where to send the messages whent they come in.
    153           *
    154           * @param   void
    155           *
    156           * @return  void
    157           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    158          void MT_UartRegisterTaskID( byte taskID )
   \                     MT_UartRegisterTaskID:
    159          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    160            App_TaskID = taskID;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#App_TaskID
   \   000008   F0           MOVX    @DPTR,A
    161          }
   \   000009   80..         SJMP    ?Subroutine0
    162          
    163          /***************************************************************************************************
    164           * @fn      SPIMgr_CalcFCS
    165           *
    166           * @brief   Calculate the FCS of a message buffer by XOR'ing each byte.
    167           *          Remember to NOT include SOP and FCS fields, so start at the CMD field.
    168           *
    169           * @param   byte *msg_ptr - message pointer
    170           * @param   byte len - length (in bytes) of message
    171           *
    172           * @return  result byte
    173           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    174          byte MT_UartCalcFCS( uint8 *msg_ptr, uint8 len )
   \                     MT_UartCalcFCS:
    175          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   FC           MOV     R4,A
    176            byte x;
    177            byte xorResult;
    178          
    179            xorResult = 0;
   \   000006   7900         MOV     R1,#0x0
    180          
    181            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000008   7800         MOV     R0,#0x0
   \   00000A   800E         SJMP    ??MT_UartCalcFCS_0
    182              xorResult = xorResult ^ *msg_ptr;
   \                     ??MT_UartCalcFCS_1:
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   E0           MOVX    A,@DPTR
   \   000011   C9           XCH     A,R1
   \   000012   69           XRL     A,R1
   \   000013   F9           MOV     R1,A
   \   000014   08           INC     R0
   \   000015   A3           INC     DPTR
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \                     ??MT_UartCalcFCS_0:
   \   00001A   E8           MOV     A,R0
   \   00001B   C3           CLR     C
   \   00001C   9C           SUBB    A,R4
   \   00001D   40ED         JC      ??MT_UartCalcFCS_1
    183          
    184            return ( xorResult );
   \   00001F   80..         SJMP    ?Subroutine0
    185          }
    186          
    187          
    188          /***************************************************************************************************
    189           * @fn      MT_UartProcessZToolData
    190           *
    191           * @brief   | SOP | Data Length  |   CMD   |   Data   |  FCS  |
    192           *          |  1  |     1        |    2    |  0-Len   |   1   |
    193           *
    194           *          Parses the data and determine either is SPI or just simply serial data
    195           *          then send the data to correct place (MT or APP)
    196           *
    197           * @param   port     - UART port
    198           *          event    - Event that causes the callback
    199           *
    200           *
    201           * @return  None
    202           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    203          void MT_UartProcessZToolData ( uint8 port, uint8 event ) //自定xУ艉 1
   \                     MT_UartProcessZToolData:
    204          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
    205            osal_event_hdr_t  *msg_ptr;
    206            uint8 uart0RxLen;
    207            //uint8 dataBuffer0[127];
    208            
    209             if(( event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT ) ) )
   \   000007   7407         MOV     A,#0x7
   \   000009   55..         ANL     A,?V0 + 0
   \   00000B   6067         JZ      ??MT_UartProcessZToolData_0
    210             {
    211               if(port == HAL_UART_PORT_0)
   \   00000D   E9           MOV     A,R1
   \   00000E   7049         JNZ     ??MT_UartProcessZToolData_1
    212               {
    213                 uart0RxLen = Hal_UART_RxBufLen(HAL_UART_PORT_0);
   \   000010                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000010   7900         MOV     R1,#0x0
   \   000012   12....       LCALL   ??Hal_UART_RxBufLen?relay
   \   000015   EA           MOV     A,R2
   \   000016   F5..         MOV     ?V0 + 4,A
    214                 
    215                 msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( uart0RxLen + sizeof(osal_event_hdr_t) );
   \   000018                ; Setup parameters for call to function osal_msg_allocate
   \   000018   2402         ADD     A,#0x2
   \   00001A   0A           INC     R2
   \   00001B   0A           INC     R2
   \   00001C   E4           CLR     A
   \   00001D   3400         ADDC    A,#0x0
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??osal_msg_allocate?relay
   \   000023   8A..         MOV     ?V0 + 2,R2
   \   000025   8B..         MOV     ?V0 + 3,R3
   \   000027   AE..         MOV     R6,?V0 + 2
   \   000029   AF..         MOV     R7,?V0 + 3
    216                 if(msg_ptr)
   \   00002B   EE           MOV     A,R6
   \   00002C   4F           ORL     A,R7
   \   00002D   6045         JZ      ??MT_UartProcessZToolData_0
    217                 {
    218                   msg_ptr->event = CMD_SERIAL_MSG_0; //串口0
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   7401         MOV     A,#0x1
   \   000035   F0           MOVX    @DPTR,A
    219                   msg_ptr->status = uart0RxLen;
   \   000036   A3           INC     DPTR
   \   000037   E5..         MOV     A,?V0 + 4
   \   000039   F0           MOVX    @DPTR,A
    220                   HalUARTRead( HAL_UART_PORT_0, (uint8 *)(msg_ptr + 1), uart0RxLen );
   \   00003A                ; Setup parameters for call to function HalUARTRead
   \   00003A   FC           MOV     R4,A
   \   00003B   7D00         MOV     R5,#0x0
   \   00003D   EE           MOV     A,R6
   \   00003E   2402         ADD     A,#0x2
   \   000040   0A           INC     R2
   \   000041   0A           INC     R2
   \   000042   EF           MOV     A,R7
   \   000043   3400         ADDC    A,#0x0
   \   000045   FB           MOV     R3,A
   \   000046   7900         MOV     R1,#0x0
   \   000048   12....       LCALL   ??HalUARTRead?relay
    221          
    222                   //HalUARTWrite(1, (uint8 *)msg_ptr, 20); 
    223                   osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
   \   00004B                ; Setup parameters for call to function osal_msg_send
   \   00004B   EE           MOV     A,R6
   \   00004C   FA           MOV     R2,A
   \   00004D   EF           MOV     A,R7
   \   00004E   FB           MOV     R3,A
   \   00004F   90....       MOV     DPTR,#App_TaskID
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F9           MOV     R1,A
   \   000054   12....       LCALL   ??osal_msg_send?relay
   \   000057   801B         SJMP    ??MT_UartProcessZToolData_0
    224                 }
    225               }else //uart1 for sim800a
    226               { 
    227                 UART1_RX_STA = 1;
   \                     ??MT_UartProcessZToolData_1:
   \   000059   90....       MOV     DPTR,#UART1_RX_STA
   \   00005C   7401         MOV     A,#0x1
   \   00005E   F0           MOVX    @DPTR,A
    228                 
    229                 Uart1RxLen = Hal_UART_RxBufLen(HAL_UART_PORT_1);
   \   00005F                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   00005F   F9           MOV     R1,A
   \   000060   12....       LCALL   ??Hal_UART_RxBufLen?relay
   \   000063   EA           MOV     A,R2
   \   000064   90....       MOV     DPTR,#Uart1RxLen
   \   000067   F0           MOVX    @DPTR,A
    230                 HalUARTRead(HAL_UART_PORT_1, UART1_RX_BUF, Uart1RxLen);
   \   000068                ; Setup parameters for call to function HalUARTRead
   \   000068   FC           MOV     R4,A
   \   000069   7D00         MOV     R5,#0x0
   \   00006B   7A..         MOV     R2,#UART1_RX_BUF & 0xff
   \   00006D   7B..         MOV     R3,#(UART1_RX_BUF >> 8) & 0xff
   \   00006F   7901         MOV     R1,#0x1
   \   000071   12....       LCALL   ??HalUARTRead?relay
    231               }
    232             }
    233          }
   \                     ??MT_UartProcessZToolData_0:
   \   000074   7F05         MOV     R7,#0x5
   \   000076   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartRegisterTaskID?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartRegisterTaskID

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartCalcFCS?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartCalcFCS

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartProcessZToolData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartProcessZToolData
    234          
    235          /*void MT_UartProcessZToolData ( uint8 port, uint8 event ) //自定xУ艉 2
    236          {
    237            uint8  ch;
    238            //uint8  bytesInRxBuffer;
    239            uint8  msglen = 0;
    240            uint8  msgBuffer[18];
    241            state = SOP_STATE;
    242            
    243            (void)event;  // Intentionally unreferenced parameter
    244            while (Hal_UART_RxBufLen(port))
    245            {
    246               HalUARTRead (port, &ch, 1); 
    247               msgBuffer[msglen ++] = ch; //存储数据
    248               switch (state)
    249               {
    250                case SOP_STATE:
    251                  if (ch == 0xEE) //帧头
    252                  {
    253                    break;
    254                  }else if (ch == 0xCC)
    255                  {
    256                    state = DATA_STATE;
    257                    break;
    258                  }else
    259                    break;
    260                case DATA_STATE:
    261                  if(msglen == 18)
    262                  {
    263                    if( ch == 0xFF)
    264                    {
    265                      pMsg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof ( mtOSALSerialData_t ));
    266                      if(pMsg)
    267                      {
    268                        if(port == 0)
    269                          pMsg->hdr.event = CMD_SERIAL_MSG_0; //串口0
    270                        else if(port == 1)
    271                          pMsg->hdr.event = CMD_SERIAL_MSG_1; //串口1
    272                        
    273                        osal_memcpy(pMsg->msg, msgBuffer, 18);
    274                        osal_msg_send( App_TaskID, (byte *)pMsg );
    275                        state = SOP_STATE;
    276                      }else
    277                      {
    278                        state = SOP_STATE;
    279                      }
    280                    }else
    281                    {
    282                      //deallocate the msg 
    283                      osal_msg_deallocate ( (uint8 *)pMsg );
    284                      state = SOP_STATE;
    285                    }
    286                  }
    287                  break;
    288                default:
    289                 break;
    290               }
    291            }
    292          }
    293          */
    294          
    295           /*
    296          void MT_UartProcessZToolData ( uint8 port, uint8 event )//系统定义回调函数
    297          {
    298            uint8  ch;
    299            uint8  bytesInRxBuffer;
    300            
    301            (void)event;  // Intentionally unreferenced parameter
    302            while (Hal_UART_RxBufLen(port))
    303            {
    304              HalUARTRead (port, &ch, 1);
    305          
    306              switch (state)
    307              {
    308                case SOP_STATE:
    309                  if (ch == MT_UART_SOF)
    310                    state = LEN_STATE;
    311                  break;
    312          
    313                case LEN_STATE:
    314                  LEN_Token = ch; //数据长度
    315          
    316                  tempDataLen = 0;
    317          
    318                  //Allocate memory for the data 
    319                  pMsg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof ( mtOSALSerialData_t ) +
    320                                                                  MT_RPC_FRAME_HDR_SZ + LEN_Token );
    321          
    322                  if (pMsg)
    323                  {
    324                    //Fill up what we can 
    325                    if(port == 0)
    326                      pMsg->hdr.event = CMD_SERIAL_MSG_0; //串口0
    327                    else if(port == 1)
    328                      pMsg->hdr.event = CMD_SERIAL_MSG_1; //串口1
    329                    
    330                    pMsg->msg = (uint8*)(pMsg+1);
    331                    pMsg->msg[MT_RPC_POS_LEN] = LEN_Token;
    332                    state = CMD_STATE1;
    333                  }
    334                  else
    335                  {
    336                    state = SOP_STATE;
    337                    return;
    338                  }
    339                  break;
    340          
    341                case CMD_STATE1:
    342                  pMsg->msg[MT_RPC_POS_CMD0] = ch;
    343                  state = CMD_STATE2;
    344                  break;
    345          
    346                case CMD_STATE2:
    347                  pMsg->msg[MT_RPC_POS_CMD1] = ch;
    348                  // If there is no data, skip to FCS state 
    349                  if (LEN_Token)
    350                  {
    351                    state = DATA_STATE;
    352                  }
    353                  else
    354                  {
    355                    state = FCS_STATE;
    356                  }
    357                  break;
    358          
    359                case DATA_STATE:
    360          
    361                  // Fill in the buffer the first byte of the data 
    362                  pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen++] = ch;
    363          
    364                  // Check number of bytes left in the Rx buffer 
    365                  bytesInRxBuffer = Hal_UART_RxBufLen(port);
    366          
    367                  // If the remain of the data is there, read them all, otherwise, just read enough 
    368                  if (bytesInRxBuffer <= LEN_Token - tempDataLen)
    369                  {
    370                    HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], bytesInRxBuffer);
    371                    tempDataLen += bytesInRxBuffer;
    372                  }
    373                  else
    374                  {
    375                    HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], LEN_Token - tempDataLen);
    376                    tempDataLen += (LEN_Token - tempDataLen);
    377                  }
    378          
    379                  // If number of bytes read is equal to data length, time to move on to FCS 
    380                  if ( tempDataLen == LEN_Token )
    381                      state = FCS_STATE;
    382          
    383                  break;
    384          
    385                case FCS_STATE:
    386          
    387                  FSC_Token = ch;
    388          
    389                  // Make sure it's correct 
    390                  if ((MT_UartCalcFCS ((uint8*)&pMsg->msg[0], MT_RPC_FRAME_HDR_SZ + LEN_Token) == FSC_Token))
    391                  {
    392                    osal_msg_send( App_TaskID, (byte *)pMsg );
    393                  }
    394                  else
    395                  {
    396                    // deallocate the msg 
    397                    osal_msg_deallocate ( (uint8 *)pMsg );
    398                  }
    399          
    400                  // Reset the state, send or discard the buffers at this point 
    401                  state = SOP_STATE;
    402          
    403                  break;
    404          
    405                default:
    406                 break;
    407              }
    408            }
    409          }*/
    410          
    411          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    412          /***************************************************************************************************
    413           * @fn      MT_UartProcessZAppData
    414           *
    415           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    416           *          |  1  |  2   |       1         |  1   |
    417           *
    418           *          Parses the data and determine either is SPI or just simply serial data
    419           *          then send the data to correct place (MT or APP)
    420           *
    421           * @param   port    - UART port
    422           *          event   - Event that causes the callback
    423           *
    424           *
    425           * @return  None
    426           ***************************************************************************************************/
    427          void MT_UartProcessZAppData ( uint8 port, uint8 event )
    428          {
    429          
    430            osal_event_hdr_t  *msg_ptr;
    431            uint16 length = 0;
    432            uint16 rxBufLen  = Hal_UART_RxBufLen(MT_UART_DEFAULT_PORT);
    433          
    434            /*
    435               If maxZAppBufferLength is 0 or larger than current length
    436               the entire length of the current buffer is returned.
    437            */
    438            if ((MT_UartMaxZAppBufLen != 0) && (MT_UartMaxZAppBufLen <= rxBufLen))
    439            {
    440              length = MT_UartMaxZAppBufLen;
    441            }
    442            else
    443            {
    444              length = rxBufLen;
    445            }
    446          
    447            /* Verify events */
    448            if (event == HAL_UART_TX_FULL)
    449            {
    450              // Do something when TX if full
    451              return;
    452            }
    453          
    454            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    455            {
    456              if ( App_TaskID )
    457              {
    458                /*
    459                   If Application is ready to receive and there is something
    460                   in the Rx buffer then send it up
    461                */
    462                if ((MT_UartZAppRxStatus == MT_UART_ZAPP_RX_READY ) && (length != 0))
    463                {
    464                  /* Disable App flow control until it processes the current data */
    465                   MT_UartAppFlowControl (MT_UART_ZAPP_RX_NOT_READY);
    466          
    467                  /* 2 more bytes are added, 1 for CMD type, other for length */
    468                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    469                  if ( msg_ptr )
    470                  {
    471                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    472                    msg_ptr->status = length;
    473          
    474                    /* Read the data of Rx buffer */
    475                    HalUARTRead( MT_UART_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    476          
    477                    /* Send the raw data to application...or where ever */
    478                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    479                  }
    480                }
    481              }
    482            }
    483          }
    484          
    485          /***************************************************************************************************
    486           * @fn      SPIMgr_ZAppBufferLengthRegister
    487           *
    488           * @brief
    489           *
    490           * @param   maxLen - Max Length that the application wants at a time
    491           *
    492           * @return  None
    493           *
    494           ***************************************************************************************************/
    495          void MT_UartZAppBufferLengthRegister ( uint16 maxLen )
    496          {
    497            /* If the maxLen is larger than the RX buff, something is not right */
    498            if (maxLen <= MT_UART_DEFAULT_MAX_RX_BUFF)
    499              MT_UartMaxZAppBufLen = maxLen;
    500            else
    501              MT_UartMaxZAppBufLen = 1; /* default is 1 byte */
    502          }
    503          
    504          /***************************************************************************************************
    505           * @fn      SPIMgr_AppFlowControl
    506           *
    507           * @brief
    508           *
    509           * @param   status - ready to send or not
    510           *
    511           * @return  None
    512           *
    513           ***************************************************************************************************/
    514          void MT_UartAppFlowControl ( bool status )
    515          {
    516          
    517            /* Make sure only update if needed */
    518            if (status != MT_UartZAppRxStatus )
    519            {
    520              MT_UartZAppRxStatus = status;
    521            }
    522          
    523            /* App is ready to read again, ProcessZAppData have to be triggered too */
    524            if (status == MT_UART_ZAPP_RX_READY)
    525            {
    526              MT_UartProcessZAppData (MT_UART_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    527            }
    528          
    529          }
    530          
    531          #endif //ZAPP
    532          
    533          /***************************************************************************************************
    534          ***************************************************************************************************/

   Maximum stack usage in bytes:

     Function                ISTACK PSTACK XSTACK
     --------                ------ ------ ------
     MT_UartCalcFCS              2      0      0
     MT_UartInit                 2      0     29
       -> HalUARTOpen            4      0     58
     MT_UartProcessZToolData     1      0     13
       -> Hal_UART_RxBufLen      0      0     26
       -> osal_msg_allocate      0      0     26
       -> HalUARTRead            0      0     26
       -> osal_msg_send          0      0     26
       -> Hal_UART_RxBufLen      0      0     26
       -> HalUARTRead            0      0     26
     MT_UartRegisterTaskID       2      0      0


   Segment part sizes:

     Function/Label                  Bytes
     --------------                  -----
     App_TaskID                         1
     state                              1
     CMD_Token                          2
     LEN_Token                          1
     FSC_Token                          1
     pMsg                               2
     tempDataLen                        1
     UART1_RX_STA                       1
     Uart1RxLen                         1
     UART1_RX_BUF                     127
     MT_UartInit                      116
     ?Subroutine0                       7
     MT_UartRegisterTaskID             11
     MT_UartCalcFCS                    33
     MT_UartProcessZToolData          121
     ??MT_UartInit?relay                6
     ??MT_UartRegisterTaskID?relay      6
     ??MT_UartCalcFCS?relay             6
     ??MT_UartProcessZToolData?relay    6

 
 288 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
 138 bytes in segment XDATA_Z
 
 312 bytes of CODE  memory
 138 bytes of XDATA memory

Errors: none
Warnings: none
