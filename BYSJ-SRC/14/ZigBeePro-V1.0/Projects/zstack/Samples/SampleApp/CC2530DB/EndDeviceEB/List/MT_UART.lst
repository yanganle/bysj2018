###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         05/Sep/2018  17:54:16 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\AnleYang\selfwork\ZigBeePro\Components\mt\MT_UA #
#                          RT.c                                               #
#    Command line       =  -f E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\ #
#                          Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB #
#                          \f8wEndev.cfg (-DCPU32MHZ -DROOT=__near_func       #
#                          -DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6         #
#                          -DMAC_CFG_RX_MAX=3) -f E:\AnleYang\selfwork\ZigBee #
#                          Pro\Projects\zstack\Samples\SampleApp\CC2530DB\..\ #
#                          ..\..\Tools\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO    #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1234                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 E:\AnleYang\selfwork\ZigBee #
#                          Pro\Components\mt\MT_UART.c -D NWK_AUTO_POLL -D    #
#                          ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC  #
#                          -D LCD_SUPPORTED=DEBUG -lC                         #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\EndDeviceEB\List\ -lA      #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\EndDeviceEB\List\          #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\EndDeviceEB\Obj\ -e        #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\ #
#                          Samples\SampleApp\CC2530DB\ -I                     #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\Source\ -I              #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\ZMain\TI2530DB\   #
#                          -I E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\ #
#                          Samples\SampleApp\CC2530DB\..\..\..\..\..\Componen #
#                          ts\hal\include\ -I E:\AnleYang\selfwork\ZigBeePro\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\hal\target\CC2530EB\ -I         #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\Components\ #
#                          mac\include\ -I E:\AnleYang\selfwork\ZigBeePro\Pro #
#                          jects\zstack\Samples\SampleApp\CC2530DB\..\..\..\. #
#                          .\..\Components\mac\high_level\ -I                 #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\Components\ #
#                          mac\low_level\srf04\ -I E:\AnleYang\selfwork\ZigBe #
#                          ePro\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\Components\mac\low_level\srf04\single #
#                          _chip\ -I E:\AnleYang\selfwork\ZigBeePro\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mt\ -I E:\AnleYang\selfwork\ZigBeePro\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\osal\include\ -I                  #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\Components\ #
#                          services\saddr\ -I E:\AnleYang\selfwork\ZigBeePro\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\services\sdata\ -I              #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\Components\ #
#                          stack\af\ -I E:\AnleYang\selfwork\ZigBeePro\Projec #
#                          ts\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\. #
#                          .\Components\stack\nwk\ -I                         #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\Components\ #
#                          stack\sapi\ -I E:\AnleYang\selfwork\ZigBeePro\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sec\ -I                       #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\Components\ #
#                          stack\sys\ -I E:\AnleYang\selfwork\ZigBeePro\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\ #
#                          ..\Components\stack\zdo\ -I                        #
#                          E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\Components\ #
#                          zmac\ -I E:\AnleYang\selfwork\ZigBeePro\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Co #
#                          mponents\zmac\f8w\ -Ohz --require_prototypes       #
#    List file          =  E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\EndDeviceEB\List\MT_UART.l #
#                          st                                                 #
#    Object file        =  E:\AnleYang\selfwork\ZigBeePro\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\EndDeviceEB\Obj\MT_UART.r5 #
#                          1                                                  #
#                                                                             #
#                                                                             #
###############################################################################

E:\AnleYang\selfwork\ZigBeePro\Components\mt\MT_UART.c
      1          /***************************************************************************************************
      2            Filename:       MT_UART.c
      3            Revised:        $Date: 2009-03-12 16:25:22 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19404 $
      5          
      6            Description:  This module handles anything dealing with the serial port.
      7          
      8            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.anlde.com.
     37          
     38          ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "hal_uart.h"
     46          #include "MT.h"
     47          #include "MT_UART.h"
     48          #include "OSAL_Memory.h"
     49          
     50          
     51          /***************************************************************************************************
     52           * MACROS
     53           ***************************************************************************************************/
     54          
     55          /***************************************************************************************************
     56           * CONSTANTS
     57           ***************************************************************************************************/
     58          /* State values for ZTool protocal */
     59          #define SOP_STATE      0x00
     60          #define CMD_STATE1     0x01
     61          #define CMD_STATE2     0x02
     62          #define LEN_STATE      0x03
     63          #define DATA_STATE     0x04
     64          #define FCS_STATE      0x05
     65          
     66          /***************************************************************************************************
     67           *                                         GLOBAL VARIABLES
     68           ***************************************************************************************************/
     69          /* Used to indentify the application ID for osal task */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     70          byte App_TaskID;
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     71          
     72          /* ZTool protocal parameters */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          uint8 state = 0;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     74          uint8  CMD_Token[2];
   \                     CMD_Token:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     75          uint8  LEN_Token;
   \                     LEN_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     76          uint8  FSC_Token;
   \                     FSC_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     77          mtOSALSerialData_t  *pMsg;
   \                     pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     78          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     79          
     80          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     81          uint16  MT_UartMaxZAppBufLen;
     82          bool    MT_UartZAppRxStatus;
     83          #endif
     84          
     85          
     86          /***************************************************************************************************
     87           *                                          LOCAL FUNCTIONS
     88           ***************************************************************************************************/
     89          
     90          /***************************************************************************************************
     91           * @fn      MT_UartInit
     92           *
     93           * @brief   Initialize MT with UART support
     94           *
     95           * @param   None
     96           *
     97           * @return  None
     98          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     99          void MT_UartInit ()
   \                     MT_UartInit:
    100          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 29
   \   000004   74E3         MOV     A,#-0x1d
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    101            halUARTCfg_t uartConfig;
    102          
    103            /* Initialize APP ID */
    104            App_TaskID = 0;
   \   000009   90....       MOV     DPTR,#App_TaskID
   \   00000C   E4           CLR     A
   \   00000D   F0           MOVX    @DPTR,A
    105          
    106            /* UART Configuration */
    107            uartConfig.configured           = TRUE;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   04           INC     A
   \   000015   F0           MOVX    @DPTR,A
    108            uartConfig.baudRate             = MT_UART_DEFAULT_BAUDRATE;
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   7404         MOV     A,#0x4
   \   00001B   F0           MOVX    @DPTR,A
    109            //uartConfig.flowControl          = MT_UART_DEFAULT_OVERFLOW;
    110            uartConfig.flowControl          = FALSE;
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
    111            uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
   \   000023   7403         MOV     A,#0x3
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   7440         MOV     A,#0x40
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E4           CLR     A
   \   00002D   F0           MOVX    @DPTR,A
    112            uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
   \   00002E   740A         MOV     A,#0xa
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   7480         MOV     A,#-0x80
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   E4           CLR     A
   \   000038   F0           MOVX    @DPTR,A
    113            uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
   \   000039   7412         MOV     A,#0x12
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   7480         MOV     A,#-0x80
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   E4           CLR     A
   \   000043   F0           MOVX    @DPTR,A
    114            uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
   \   000044   7405         MOV     A,#0x5
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   7406         MOV     A,#0x6
   \   00004B   F0           MOVX    @DPTR,A
    115            uartConfig.intEnable            = TRUE;
   \   00004C   7416         MOV     A,#0x16
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   7401         MOV     A,#0x1
   \   000053   F0           MOVX    @DPTR,A
    116          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    117            uartConfig.callBackFunc         = MT_UartProcessZToolData; //串口接受回调函数
   \   000054   741B         MOV     A,#0x1b
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   74..         MOV     A,#??MT_UartProcessZToolData?relay & 0xff
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   74..         MOV     A,#(??MT_UartProcessZToolData?relay >> 8) & 0xff
   \   00005F   F0           MOVX    @DPTR,A
    118          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    119            uartConfig.callBackFunc         = MT_UartProcessZAppData;
    120          #else
    121            uartConfig.callBackFunc         = NULL;
    122          #endif
    123          
    124            /* Start UART */
    125          #if defined (MT_UART_DEFAULT_PORT)
    126            HalUARTOpen (MT_UART_DEFAULT_PORT, &uartConfig);
   \   000060                ; Setup parameters for call to function HalUARTOpen
   \   000060   85..82       MOV     DPL,?XSP + 0
   \   000063   85..83       MOV     DPH,?XSP + 1
   \   000066   AA82         MOV     R2,DPL
   \   000068   AB83         MOV     R3,DPH
   \   00006A   7900         MOV     R1,#0x0
   \   00006C   12....       LCALL   ??HalUARTOpen?relay
    127          #ifdef COOR_DEVICE_UART1 //配置串口1
    128            HalUARTOpen (1, &uartConfig);
    129          #endif
    130          #else
    131            /* Silence IAR compiler warning */
    132            (void)uartConfig;
    133          #endif
    134          
    135            /* Initialize for ZApp */
    136          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    137            /* Default max bytes that ZAPP can take */
    138            MT_UartMaxZAppBufLen  = 1;
    139            MT_UartZAppRxStatus   = MT_UART_ZAPP_RX_READY;
    140          #endif
    141          
    142          }
   \   00006F   741D         MOV     A,#0x1d
   \   000071   12....       LCALL   ?DEALLOC_XSTACK8
   \   000074                REQUIRE ?Subroutine0
   \   000074                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    143          
    144          /***************************************************************************************************
    145           * @fn      MT_SerialRegisterTaskID
    146           *
    147           * @brief   This function registers the taskID of the application so it knows
    148           *          where to send the messages whent they come in.
    149           *
    150           * @param   void
    151           *
    152           * @return  void
    153           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    154          void MT_UartRegisterTaskID( byte taskID )
   \                     MT_UartRegisterTaskID:
    155          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    156            App_TaskID = taskID;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#App_TaskID
   \   000008   F0           MOVX    @DPTR,A
    157          }
   \   000009   80..         SJMP    ?Subroutine0
    158          
    159          /***************************************************************************************************
    160           * @fn      SPIMgr_CalcFCS
    161           *
    162           * @brief   Calculate the FCS of a message buffer by XOR'ing each byte.
    163           *          Remember to NOT include SOP and FCS fields, so start at the CMD field.
    164           *
    165           * @param   byte *msg_ptr - message pointer
    166           * @param   byte len - length (in bytes) of message
    167           *
    168           * @return  result byte
    169           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    170          byte MT_UartCalcFCS( uint8 *msg_ptr, uint8 len )
   \                     MT_UartCalcFCS:
    171          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   FC           MOV     R4,A
    172            byte x;
    173            byte xorResult;
    174          
    175            xorResult = 0;
   \   000006   7900         MOV     R1,#0x0
    176          
    177            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000008   7800         MOV     R0,#0x0
   \   00000A   800E         SJMP    ??MT_UartCalcFCS_0
    178              xorResult = xorResult ^ *msg_ptr;
   \                     ??MT_UartCalcFCS_1:
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   E0           MOVX    A,@DPTR
   \   000011   C9           XCH     A,R1
   \   000012   69           XRL     A,R1
   \   000013   F9           MOV     R1,A
   \   000014   08           INC     R0
   \   000015   A3           INC     DPTR
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \                     ??MT_UartCalcFCS_0:
   \   00001A   E8           MOV     A,R0
   \   00001B   C3           CLR     C
   \   00001C   9C           SUBB    A,R4
   \   00001D   40ED         JC      ??MT_UartCalcFCS_1
    179          
    180            return ( xorResult );
   \   00001F   80..         SJMP    ?Subroutine0
    181          }
    182          
    183          
    184          /***************************************************************************************************
    185           * @fn      MT_UartProcessZToolData
    186           *
    187           * @brief   | SOP | Data Length  |   CMD   |   Data   |  FCS  |
    188           *          |  1  |     1        |    2    |  0-Len   |   1   |
    189           *
    190           *          Parses the data and determine either is SPI or just simply serial data
    191           *          then send the data to correct place (MT or APP)
    192           *
    193           * @param   port     - UART port
    194           *          event    - Event that causes the callback
    195           *
    196           *
    197           * @return  None
    198           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    199          void MT_UartProcessZToolData ( uint8 port, uint8 event ) //自定xУ艉
   \                     MT_UartProcessZToolData:
    200          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 19
   \   000005   74ED         MOV     A,#-0x13
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    201            uint8  ch;
    202            //uint8  bytesInRxBuffer;
    203            uint8  msglen = 0;
   \   00000C   7F00         MOV     R7,#0x0
    204            uint8  msgBuffer[18];
    205            state = SOP_STATE;
   \                     ??MT_UartProcessZToolData_0:
   \   00000E   90....       MOV     DPTR,#state
   \   000011   E4           CLR     A
   \   000012   8015         SJMP    ??MT_UartProcessZToolData_1
    206            
    207            (void)event;  // Intentionally unreferenced parameter
    208            while (Hal_UART_RxBufLen(port))
    209            {
    210               HalUARTRead (port, &ch, 1); 
    211               msgBuffer[msglen ++] = ch; //存储数据
    212               switch (state)
    213               {
    214                case SOP_STATE:
    215                  if (ch == 0xEE) //帧头
   \                     ??MT_UartProcessZToolData_2:
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   64EE         XRL     A,#0xee
   \   00001D   600B         JZ      ??MT_UartProcessZToolData_3
    216                  {
    217                    break;
    218                  }else if (ch == 0xCC)
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   64CC         XRL     A,#0xcc
   \   000022   7006         JNZ     ??MT_UartProcessZToolData_3
    219                  {
    220                    state = DATA_STATE;
   \   000024   90....       MOV     DPTR,#state
   \   000027   7404         MOV     A,#0x4
   \                     ??MT_UartProcessZToolData_1:
   \   000029   F0           MOVX    @DPTR,A
    221                    break;
    222                  }else
   \                     ??MT_UartProcessZToolData_3:
   \   00002A                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   00002A   EE           MOV     A,R6
   \   00002B   F9           MOV     R1,A
   \   00002C   12....       LCALL   ??Hal_UART_RxBufLen?relay
   \   00002F   8B..         MOV     ?V0 + 1,R3
   \   000031   EA           MOV     A,R2
   \   000032   45..         ORL     A,?V0 + 1
   \   000034   7003         JNZ     $+5
   \   000036   02....       LJMP    ??MT_UartProcessZToolData_4 & 0xFFFF
   \   000039                ; Setup parameters for call to function HalUARTRead
   \   000039   7C01         MOV     R4,#0x1
   \   00003B   7D00         MOV     R5,#0x0
   \   00003D   85..82       MOV     DPL,?XSP + 0
   \   000040   85..83       MOV     DPH,?XSP + 1
   \   000043   AA82         MOV     R2,DPL
   \   000045   AB83         MOV     R3,DPH
   \   000047   EE           MOV     A,R6
   \   000048   F9           MOV     R1,A
   \   000049   12....       LCALL   ??HalUARTRead?relay
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   E0           MOVX    A,@DPTR
   \   000053   C0E0         PUSH    A
   \   000055   8F..         MOV     ?V0 + 0,R7
   \   000057   7401         MOV     A,#0x1
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   E582         MOV     A,DPL
   \   00005E   25..         ADD     A,?V0 + 0
   \   000060   F582         MOV     DPL,A
   \   000062   E583         MOV     A,DPH
   \   000064   3400         ADDC    A,#0x0
   \   000066   F583         MOV     DPH,A
   \   000068   D0E0         POP     A
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   0F           INC     R7
   \   00006C   90....       MOV     DPTR,#state
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   60A2         JZ      ??MT_UartProcessZToolData_2
   \   000072   24FC         ADD     A,#-0x4
   \   000074   70B4         JNZ     ??MT_UartProcessZToolData_3
    223                    break;
    224                case DATA_STATE:
    225                  if(msglen == 18)
   \   000076   7412         MOV     A,#0x12
   \   000078   6F           XRL     A,R7
   \   000079   70AF         JNZ     ??MT_UartProcessZToolData_3
    226                  {
    227                    if( ch == 0xFF)
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F4           CPL     A
   \   000083   707D         JNZ     ??MT_UartProcessZToolData_5
    228                    {
    229                      pMsg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof ( mtOSALSerialData_t ));
   \   000085                ; Setup parameters for call to function osal_msg_allocate
   \   000085   7A04         MOV     R2,#0x4
   \   000087   7B00         MOV     R3,#0x0
   \   000089   12....       LCALL   ??osal_msg_allocate?relay
   \   00008C   90....       MOV     DPTR,#pMsg
   \   00008F   EA           MOV     A,R2
   \   000090   F0           MOVX    @DPTR,A
   \   000091   A3           INC     DPTR
   \   000092   EB           MOV     A,R3
   \   000093   F0           MOVX    @DPTR,A
    230                      if(pMsg)
   \   000094   90....       MOV     DPTR,#pMsg
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F8           MOV     R0,A
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   F9           MOV     R1,A
   \   00009C   E8           MOV     A,R0
   \   00009D   49           ORL     A,R1
   \   00009E   605F         JZ      ??MT_UartProcessZToolData_6
    231                      {
    232                        if(port == 0)
   \   0000A0   EE           MOV     A,R6
   \   0000A1   7009         JNZ     ??MT_UartProcessZToolData_7
    233                          pMsg->hdr.event = CMD_SERIAL_MSG_0; //串口0
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   F583         MOV     DPH,A
   \   0000A6   8882         MOV     DPL,R0
   \   0000A8   7401         MOV     A,#0x1
   \   0000AA   800C         SJMP    ??MT_UartProcessZToolData_8
    234                        else if(port == 1)
   \                     ??MT_UartProcessZToolData_7:
   \   0000AC   7401         MOV     A,#0x1
   \   0000AE   6E           XRL     A,R6
   \   0000AF   7008         JNZ     ??MT_UartProcessZToolData_9
    235                          pMsg->hdr.event = CMD_SERIAL_MSG_1; //串口1
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   F583         MOV     DPH,A
   \   0000B4   8882         MOV     DPL,R0
   \   0000B6   7407         MOV     A,#0x7
   \                     ??MT_UartProcessZToolData_8:
   \   0000B8   F0           MOVX    @DPTR,A
    236                        
    237                        osal_memcpy(pMsg->msg, msgBuffer, 18);
   \                     ??MT_UartProcessZToolData_9:
   \   0000B9                ; Setup parameters for call to function osal_memcpy
   \   0000B9   7401         MOV     A,#0x1
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   A982         MOV     R1,DPL
   \   0000C0   AA83         MOV     R2,DPH
   \   0000C2   89..         MOV     ?V0 + 0,R1
   \   0000C4   8A..         MOV     ?V0 + 1,R2
   \   0000C6   75..00       MOV     ?V0 + 2,#0x0
   \   0000C9   78..         MOV     R0,#?V0 + 0
   \   0000CB   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000CE   7C12         MOV     R4,#0x12
   \   0000D0   7D00         MOV     R5,#0x0
   \   0000D2   90....       MOV     DPTR,#pMsg
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   F8           MOV     R0,A
   \   0000D7   A3           INC     DPTR
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   F583         MOV     DPH,A
   \   0000DB   8882         MOV     DPL,R0
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   FA           MOV     R2,A
   \   0000E1   A3           INC     DPTR
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   FB           MOV     R3,A
   \   0000E4   12....       LCALL   ??osal_memcpy?relay
   \   0000E7   7403         MOV     A,#0x3
   \   0000E9   12....       LCALL   ?DEALLOC_XSTACK8
    238                        osal_msg_send( App_TaskID, (byte *)pMsg );
   \   0000EC                ; Setup parameters for call to function osal_msg_send
   \   0000EC   90....       MOV     DPTR,#pMsg
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   FA           MOV     R2,A
   \   0000F1   A3           INC     DPTR
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   FB           MOV     R3,A
   \   0000F4   90....       MOV     DPTR,#App_TaskID
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   F9           MOV     R1,A
   \   0000F9   12....       LCALL   ??osal_msg_send?relay
    239                        state = SOP_STATE;
   \   0000FC   02....       LJMP    ??MT_UartProcessZToolData_0 & 0xFFFF
    240                      }else
    241                      {
    242                        state = SOP_STATE;
   \                     ??MT_UartProcessZToolData_6:
   \   0000FF   02....       LJMP    ??MT_UartProcessZToolData_0 & 0xFFFF
    243                      }
    244                    }else
    245                    {
    246                      //deallocate the msg 
    247                      osal_msg_deallocate ( (uint8 *)pMsg );
   \                     ??MT_UartProcessZToolData_5:
   \   000102                ; Setup parameters for call to function osal_msg_deallocate
   \   000102   90....       MOV     DPTR,#pMsg
   \   000105   E0           MOVX    A,@DPTR
   \   000106   FA           MOV     R2,A
   \   000107   A3           INC     DPTR
   \   000108   E0           MOVX    A,@DPTR
   \   000109   FB           MOV     R3,A
   \   00010A   12....       LCALL   ??osal_msg_deallocate?relay
    248                      state = SOP_STATE;
   \   00010D   02....       LJMP    ??MT_UartProcessZToolData_0 & 0xFFFF
    249                    }
    250                  }
    251                  break;
    252                default:
    253                 break;
    254               }
    255            }
    256          }
   \                     ??MT_UartProcessZToolData_4:
   \   000110   7413         MOV     A,#0x13
   \   000112   12....       LCALL   ?DEALLOC_XSTACK8
   \   000115   7F03         MOV     R7,#0x3
   \   000117   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartRegisterTaskID?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartRegisterTaskID

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartCalcFCS?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartCalcFCS

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartProcessZToolData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartProcessZToolData
    257           /*void MT_UartProcessZToolData ( uint8 port, uint8 event )
    258          {
    259            uint8  ch;
    260            uint8  bytesInRxBuffer;
    261            
    262            (void)event;  // Intentionally unreferenced parameter
    263            while (Hal_UART_RxBufLen(port))
    264            {
    265              HalUARTRead (port, &ch, 1);
    266          
    267              switch (state)
    268              {
    269                case SOP_STATE:
    270                  if (ch == MT_UART_SOF)
    271                    state = LEN_STATE;
    272                  break;
    273          
    274                case LEN_STATE:
    275                  LEN_Token = ch; //数据长度
    276          
    277                  tempDataLen = 0;
    278          
    279                  //Allocate memory for the data 
    280                  pMsg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof ( mtOSALSerialData_t ) +
    281                                                                  MT_RPC_FRAME_HDR_SZ + LEN_Token );
    282          
    283                  if (pMsg)
    284                  {
    285                    //Fill up what we can 
    286                    if(port == 0)
    287                      pMsg->hdr.event = CMD_SERIAL_MSG_0; //串口0
    288                    else if(port == 1)
    289                      pMsg->hdr.event = CMD_SERIAL_MSG_1; //串口1
    290                    
    291                    pMsg->msg = (uint8*)(pMsg+1);
    292                    pMsg->msg[MT_RPC_POS_LEN] = LEN_Token;
    293                    state = CMD_STATE1;
    294                  }
    295                  else
    296                  {
    297                    state = SOP_STATE;
    298                    return;
    299                  }
    300                  break;
    301          
    302                case CMD_STATE1:
    303                  pMsg->msg[MT_RPC_POS_CMD0] = ch;
    304                  state = CMD_STATE2;
    305                  break;
    306          
    307                case CMD_STATE2:
    308                  pMsg->msg[MT_RPC_POS_CMD1] = ch;
    309                  // If there is no data, skip to FCS state 
    310                  if (LEN_Token)
    311                  {
    312                    state = DATA_STATE;
    313                  }
    314                  else
    315                  {
    316                    state = FCS_STATE;
    317                  }
    318                  break;
    319          
    320                case DATA_STATE:
    321          
    322                  // Fill in the buffer the first byte of the data 
    323                  pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen++] = ch;
    324          
    325                  // Check number of bytes left in the Rx buffer 
    326                  bytesInRxBuffer = Hal_UART_RxBufLen(port);
    327          
    328                  // If the remain of the data is there, read them all, otherwise, just read enough 
    329                  if (bytesInRxBuffer <= LEN_Token - tempDataLen)
    330                  {
    331                    HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], bytesInRxBuffer);
    332                    tempDataLen += bytesInRxBuffer;
    333                  }
    334                  else
    335                  {
    336                    HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], LEN_Token - tempDataLen);
    337                    tempDataLen += (LEN_Token - tempDataLen);
    338                  }
    339          
    340                  // If number of bytes read is equal to data length, time to move on to FCS 
    341                  if ( tempDataLen == LEN_Token )
    342                      state = FCS_STATE;
    343          
    344                  break;
    345          
    346                case FCS_STATE:
    347          
    348                  FSC_Token = ch;
    349          
    350                  // Make sure it's correct 
    351                  if ((MT_UartCalcFCS ((uint8*)&pMsg->msg[0], MT_RPC_FRAME_HDR_SZ + LEN_Token) == FSC_Token))
    352                  {
    353                    osal_msg_send( App_TaskID, (byte *)pMsg );
    354                  }
    355                  else
    356                  {
    357                    // deallocate the msg 
    358                    osal_msg_deallocate ( (uint8 *)pMsg );
    359                  }
    360          
    361                  // Reset the state, send or discard the buffers at this point 
    362                  state = SOP_STATE;
    363          
    364                  break;
    365          
    366                default:
    367                 break;
    368              }
    369            }
    370          }*/
    371          
    372          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    373          /***************************************************************************************************
    374           * @fn      MT_UartProcessZAppData
    375           *
    376           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    377           *          |  1  |  2   |       1         |  1   |
    378           *
    379           *          Parses the data and determine either is SPI or just simply serial data
    380           *          then send the data to correct place (MT or APP)
    381           *
    382           * @param   port    - UART port
    383           *          event   - Event that causes the callback
    384           *
    385           *
    386           * @return  None
    387           ***************************************************************************************************/
    388          void MT_UartProcessZAppData ( uint8 port, uint8 event )
    389          {
    390          
    391            osal_event_hdr_t  *msg_ptr;
    392            uint16 length = 0;
    393            uint16 rxBufLen  = Hal_UART_RxBufLen(MT_UART_DEFAULT_PORT);
    394          
    395            /*
    396               If maxZAppBufferLength is 0 or larger than current length
    397               the entire length of the current buffer is returned.
    398            */
    399            if ((MT_UartMaxZAppBufLen != 0) && (MT_UartMaxZAppBufLen <= rxBufLen))
    400            {
    401              length = MT_UartMaxZAppBufLen;
    402            }
    403            else
    404            {
    405              length = rxBufLen;
    406            }
    407          
    408            /* Verify events */
    409            if (event == HAL_UART_TX_FULL)
    410            {
    411              // Do something when TX if full
    412              return;
    413            }
    414          
    415            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    416            {
    417              if ( App_TaskID )
    418              {
    419                /*
    420                   If Application is ready to receive and there is something
    421                   in the Rx buffer then send it up
    422                */
    423                if ((MT_UartZAppRxStatus == MT_UART_ZAPP_RX_READY ) && (length != 0))
    424                {
    425                  /* Disable App flow control until it processes the current data */
    426                   MT_UartAppFlowControl (MT_UART_ZAPP_RX_NOT_READY);
    427          
    428                  /* 2 more bytes are added, 1 for CMD type, other for length */
    429                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    430                  if ( msg_ptr )
    431                  {
    432                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    433                    msg_ptr->status = length;
    434          
    435                    /* Read the data of Rx buffer */
    436                    HalUARTRead( MT_UART_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    437          
    438                    /* Send the raw data to application...or where ever */
    439                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    440                  }
    441                }
    442              }
    443            }
    444          }
    445          
    446          /***************************************************************************************************
    447           * @fn      SPIMgr_ZAppBufferLengthRegister
    448           *
    449           * @brief
    450           *
    451           * @param   maxLen - Max Length that the application wants at a time
    452           *
    453           * @return  None
    454           *
    455           ***************************************************************************************************/
    456          void MT_UartZAppBufferLengthRegister ( uint16 maxLen )
    457          {
    458            /* If the maxLen is larger than the RX buff, something is not right */
    459            if (maxLen <= MT_UART_DEFAULT_MAX_RX_BUFF)
    460              MT_UartMaxZAppBufLen = maxLen;
    461            else
    462              MT_UartMaxZAppBufLen = 1; /* default is 1 byte */
    463          }
    464          
    465          /***************************************************************************************************
    466           * @fn      SPIMgr_AppFlowControl
    467           *
    468           * @brief
    469           *
    470           * @param   status - ready to send or not
    471           *
    472           * @return  None
    473           *
    474           ***************************************************************************************************/
    475          void MT_UartAppFlowControl ( bool status )
    476          {
    477          
    478            /* Make sure only update if needed */
    479            if (status != MT_UartZAppRxStatus )
    480            {
    481              MT_UartZAppRxStatus = status;
    482            }
    483          
    484            /* App is ready to read again, ProcessZAppData have to be triggered too */
    485            if (status == MT_UART_ZAPP_RX_READY)
    486            {
    487              MT_UartProcessZAppData (MT_UART_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    488            }
    489          
    490          }
    491          
    492          #endif //ZAPP
    493          
    494          /***************************************************************************************************
    495          ***************************************************************************************************/

   Maximum stack usage in bytes:

     Function                 ISTACK PSTACK XSTACK
     --------                 ------ ------ ------
     MT_UartCalcFCS               2      0      0
     MT_UartInit                  2      0     29
       -> HalUARTOpen             4      0     58
     MT_UartProcessZToolData      1      0     33
       -> Hal_UART_RxBufLen       0      0     60
       -> HalUARTRead             0      0     60
       -> osal_msg_allocate       0      0     60
       -> osal_memcpy             0      0     66
       -> osal_msg_send           0      0     60
       -> osal_msg_deallocate     0      0     60
     MT_UartRegisterTaskID        2      0      0


   Segment part sizes:

     Function/Label                  Bytes
     --------------                  -----
     App_TaskID                         1
     state                              1
     CMD_Token                          2
     LEN_Token                          1
     FSC_Token                          1
     pMsg                               2
     tempDataLen                        1
     MT_UartInit                      116
     ?Subroutine0                       7
     MT_UartRegisterTaskID             11
     MT_UartCalcFCS                    33
     MT_UartProcessZToolData          282
     ??MT_UartInit?relay                6
     ??MT_UartRegisterTaskID?relay      6
     ??MT_UartCalcFCS?relay             6
     ??MT_UartProcessZToolData?relay    6

 
 449 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
   9 bytes in segment XDATA_Z
 
 473 bytes of CODE  memory
   9 bytes of XDATA memory

Errors: none
Warnings: none
